---
id: b1w33kn8
title: King Piece
file_version: 1.1.3
app_version: 1.18.32
---

# King class implementation

<br/>

This code snippet defines a data class called `King` that implements the `PieceType` interface. It represents a king piece in a game. The `King` class has properties such as `name`, `point`, `image`, and `castleRookPositions`.

The `King` class overrides the `movePattern` function from the `PieceType` interface. This function calculates and returns a set of valid positions that the king can move to, based on the given parameters. The function checks for valid positions in horizontal, vertical, and diagonal directions, and adds them to the `validPositions` set if they meet certain conditions.
<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->
### ðŸ“„ app/src/main/kotlin/chess/common/model/pieceTypes/King.kt
```kotlin
7      data class King(
8          override val name: String = "king",
9          override val point: Int? = null,
10         override val image: String = " K ",
11         val castleRookPositions: MutableList<Position> = mutableListOf(),
12     ) : PieceType {
13         override fun movePattern(
14             position: Position,
15             playerPiecePositions: List<String>,
16             otherPlayerPiecePositions: List<String>,
17             otherPlayerAllOpenPieces: List<Position>,
18         ): Set<Position> {
19             val validPositions = mutableSetOf<Position>()
20     
21             validPositions.addAll(
22                 castleRookPositions
23                     .map { rookPosition ->
24                         Position(
25                             position.row,
26                             ((position.column.toColumnNumber() + rookPosition.column.toColumnNumber()) / 2 + 1).toColumn(),
27                         )
28                     }
29                     .filter { newPosition ->
30                         !otherPlayerPiecePositions.contains(newPosition.toString()) &&
31                             !playerPiecePositions.contains(newPosition.toString())
32                     },
33             )
34     
35             fun addIfValid(
36                 colOffset: Int,
37                 rowOffset: Int,
38             ) {
39                 val newCol = position.column.toColumnNumber() + colOffset + 1
40                 val newRow = position.row + rowOffset
41     
42                 if (newCol in 1..8 && newRow in 1..8) {
43                     val newPosition = Position(newRow, newCol.toColumn())
44                     if (!playerPiecePositions.contains(newPosition.toString()) &&
45                         otherPlayerAllOpenPieces.none { it.toString() == newPosition.toString() }
46                     ) {
47                         validPositions.add(newPosition)
48                     }
49                 }
50             }
51     
52             // Horizontal and Vertical
53             for (offset in -1..1) {
54                 for (innerOffset in -1..1) {
55                     if (offset != 0 || innerOffset != 0) {
56                         addIfValid(offset, innerOffset)
57                     }
58                 }
59             }
60     
61             // Diagonals
62             for (colOffset in -1..1) {
63                 for (rowOffset in -1..1) {
64                     if (colOffset != 0 || rowOffset != 0) {
65                         addIfValid(colOffset, rowOffset)
66                     }
67                 }
68             }
69     
70             // fancyPrintln("These are the valid positions: $validPositions")
71             return validPositions
72         }
73     }
```

<br/>

<br/>

<br/>

This file was generated by Swimm. [Click here to view it in the app](https://app.swimm.io/repos/Z2l0aHViJTNBJTNBQ2hlc3MlM0ElM0FvYnNjdXJlLXN0YXI=/docs/b1w33kn8).
